package semagrams.sprites

import semagrams.acsets._
import com.raquo.laminar.api.L.svg._
import com.raquo.laminar.api._
import semagrams._
import semagrams.util._
import semagrams._

case class Arrow() extends Sprite {
  def blockPath(
      s: Complex,
      e: Complex,
      d: Double,
      bend: Double
  ): Seq[Path.Element] = {
    import Path.Element._
    
    val ts = (0 to 100).map(_*.01)
    val p1 = ts.map(t => crv.pos(s,t) + d * crv.dir(s,t)*Complex(0,1))
    val p2 = ts.map(t => crv.pos(s,t) + d * crv.dir(s,t)*Complex(0,-1)).reverse

    Seq(MoveTo(p1.head)) 
      ++ p1.tail.map(LineTo(_))
      ++ Seq(LineTo(p2.head))
      ++ p2.tail.map(LineTo(_))
      ++ Seq(ClosePath)
  }

  def curvedPath(s: Complex, e: Complex, bend: Double): Seq[Path.Element] = {
    import Path.Element._
    val rot = Complex(0, bend).exp
    val cs = rot * (s * (-1 / 4) + e * (1 / 4)) + s
    val ce = rot.cong * (s * (1 / 4) + e * (-1 / 4)) + e
    Seq(MoveTo(s), Cubic(cs, ce, e))
  }

  def loopPath(s: Complex, e: Complex,ctr: Complex,bend:Double): Seq[Path.Element] =
    import Path.Element._

    Seq(MoveTo(s),
      Cubic(
        s + (1 + 5*bend)*(s - ctr), 
        e + (1 + 5*bend)*(e - ctr),
        e
      ),
    )

  def present(
      ent: Entity,
      p: PropMap,
      $p: L.Signal[PropMap]
  ): RenderedSprite = {
    val arrow = path(
      pathElts <-- $p.map(p => curvedPath(p(Start), p(End), p(Bend))),
      stroke <-- $p.map(_(Stroke)),
      strokeDashArray <-- $p.map(_.get(StrokeDasharray).getOrElse("none")),
      fill := "none",
      markerEnd := "url(#arrowhead)",
      pointerEvents := "none"
    )
    val handle = path(
      pathElts <-- $p.map(
        p => blockPath(p(Start),ppath(p)(1),d)
      ),
      fill := "white",
      opacity := "0",
      pathElts <-- $p.map(p => blockPath(p(Start), p(End), 5, p(Bend)))
    )
    val root = g(arrow, handle)
    RenderedSprite(root, Map(MainHandle -> handle))
  }
}

object Arrow {
  val defaults = PropMap()
    + (Stroke, "black")
    + (Bend, 0)
    + (StrokeDasharray, "none")
    + (Interactable, true)

  def boundaryPt(data: PropMap, dir: Complex): Complex =
    Complex(0, 0)
}
