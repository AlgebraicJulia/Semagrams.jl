[
  {
    "objectID": "roadmap.html",
    "href": "roadmap.html",
    "title": "Roadmap",
    "section": "",
    "text": "On this page, I lay out the development priorities for Semagrams. As of yet, concrete dates, or even an order of development, have not been set.\nThis is organized in two “dimensions.” One dimension is by full-stack experiences (i.e. top-down planning), and one is by features (i.e. bottom-up planning)."
  },
  {
    "objectID": "roadmap.html#box-port-wire-acset-editing",
    "href": "roadmap.html#box-port-wire-acset-editing",
    "title": "Roadmap",
    "section": "Box-Port-Wire ACSet Editing",
    "text": "Box-Port-Wire ACSet Editing\nEssentially the functionality of Semagrams Legacy."
  },
  {
    "objectID": "roadmap.html#undirected-wiring-diagram-operads",
    "href": "roadmap.html#undirected-wiring-diagram-operads",
    "title": "Roadmap",
    "section": "Undirected Wiring Diagram Operads",
    "text": "Undirected Wiring Diagram Operads\nWe should be able to draw undirected wiring diagrams, and then fill them with either other undirected wiring diagrams or elements of an algebra of undirected wiring diagrams."
  },
  {
    "objectID": "roadmap.html#process-diagrams",
    "href": "roadmap.html#process-diagrams",
    "title": "Roadmap",
    "section": "Process diagrams",
    "text": "Process diagrams\nFrom a palette of processes, we should be able to create directed wiring diagrams, and compose them vertically, horizontally, and operadically."
  },
  {
    "objectID": "roadmap.html#string-diagrams",
    "href": "roadmap.html#string-diagrams",
    "title": "Roadmap",
    "section": "String diagrams",
    "text": "String diagrams\nEssentially the functionality of homotopy.io, but integrated with Catlab."
  },
  {
    "objectID": "roadmap.html#petri-nets",
    "href": "roadmap.html#petri-nets",
    "title": "Roadmap",
    "section": "Petri Nets",
    "text": "Petri Nets\nTo some extend petri nets fall under box-port-wire editing. But there are probably some custom features that would be useful to do with them."
  },
  {
    "objectID": "roadmap.html#editing",
    "href": "roadmap.html#editing",
    "title": "Roadmap",
    "section": "Editing",
    "text": "Editing\n\nAdd/remove entities\nConnect entities\nEdit attributes\nPalettes\nChained deletion (i.e., delete connected wires or leave them dangling)"
  },
  {
    "objectID": "roadmap.html#interaction",
    "href": "roadmap.html#interaction",
    "title": "Roadmap",
    "section": "Interaction",
    "text": "Interaction\n\nHovering\nMultiple selections\nKeypresses\nDialogues\nForms inputs"
  },
  {
    "objectID": "roadmap.html#layout",
    "href": "roadmap.html#layout",
    "title": "Roadmap",
    "section": "Layout",
    "text": "Layout\n\nForce-based layout\nHierarchical (tree-based)\nManual adjustments to automatic layout"
  },
  {
    "objectID": "roadmap.html#nested-semagrams",
    "href": "roadmap.html#nested-semagrams",
    "title": "Roadmap",
    "section": "Nested Semagrams",
    "text": "Nested Semagrams\n\nZooming in/out\nExpanding/collapsing parts of a diagram"
  },
  {
    "objectID": "roadmap.html#tikz-export",
    "href": "roadmap.html#tikz-export",
    "title": "Roadmap",
    "section": "TikZ Export",
    "text": "TikZ Export\nThe representation of sprites should be abstract enough that it can be “exported” to SVG (i.e. displayed in a web browser) or exported to TikZ."
  },
  {
    "objectID": "roadmap.html#apis",
    "href": "roadmap.html#apis",
    "title": "Roadmap",
    "section": "APIs",
    "text": "APIs\n\nWebsocket API for backends (like Julia)\nJavascript API for embedding\nStandalone saving/loading files"
  },
  {
    "objectID": "roadmap.html#api-functionality",
    "href": "roadmap.html#api-functionality",
    "title": "Roadmap",
    "section": "API functionality",
    "text": "API functionality\n\nSaving and loading diagrams\nRewriting\nControlling limits/colimits/oapply"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Semagrams",
    "section": "",
    "text": "Semagrams is a tool for interacting with semantic diagrams. Semantic diagrams are graphical representations of data that have “teeth”; i.e. where there is a formal and machine-readable correspondence between the graphical display and the semantic meaning.\nThe primary component of Semagrams is a Scala.js library that provides components for creating interactive web-based UIs that manipulate semantic diagrams. However, there is also a Julia library that provides a backend that allows Semagrams to interact with Catlab, so that Semagrams can be an interface for scientific computing."
  },
  {
    "objectID": "index.html#entities",
    "href": "index.html#entities",
    "title": "Semagrams",
    "section": "Entities",
    "text": "Entities\nThe core idea behind Semagrams is that most diagrams used in mathematics and science can be seen as describing relationships between logical entities.\nFor instance, a graph has two types of entities: vertices and edges. An edge has two relationships with vertices: it has a source vertex and a target vertex.\nEntities can also have attributes, such as labels or numerical data."
  },
  {
    "objectID": "index.html#sprites",
    "href": "index.html#sprites",
    "title": "Semagrams",
    "section": "Sprites",
    "text": "Sprites\nIn order to display collections of entities and relations on the screen, we assign each type of entity to a graphical representation, which we call a sprite. Then the relationships between the entities constrain how their corresponding sprites are displayed on the screen.\nFor instance, we might assign a circular sprite to each vertex in a graph, and a line to each edge. Then there are constraints that say that one end of the line must be connected to the sprite corresponding to the source of the edge, and the other end must be connected to the sprite corresponding to the target.\nFinally, attributes of an entity translate into graphical properties of the sprites. For instance, a numerical attribute could be translated into the color of the sprite, or a textual attribute into a label for the sprite.\nNote that the mapping from logical descriptions of entities and relations to graphical representations is many-to-one; there are many valid ways to lay out a picture. In Semagrams, we will use both manual layout (dragging the sprites to the desired positions) and automatic layout (running an algorithm to determine some sort of “optimal” layout).\nIn Semagrams Legacy, there were hardcoded and special-cased in certain types of entities and certain corresponding sprite types, for boxes, ports, and wires; one of the innovations of new Semagrams is to treat entities and sprites fully generically."
  },
  {
    "objectID": "index.html#actions",
    "href": "index.html#actions",
    "title": "Semagrams",
    "section": "Actions",
    "text": "Actions\nAnother innovation of new Semagrams is a rich language for describing actions. An action is a description of an interaction with Semagrams, which can include\n\nKeypresses\nMouse movement\nSelection of entities\nCommunication with external APIs (such as Julia)\nAdding/deleting entities\nChanging entity relations\n\nThis action language uses monads in Scala in order to describe complex interactions with ease. For instance, the interaction of creating an edges might be coded as\nfor {\n  _ <- displayPrompt(\"Click on the source\")\n  s <- selectEntity[V]\n  _ <- displayPrompt(\"Click on the target\")\n  t <- selectEntity[V]\n  e <- makeEdge(s,t)\n  _ <- displayPromptTimed(\"Edge created!\", 1)\n} yield e\nCrucially, the action language allows asynchronous interaction to be represented without explicit callbacks or state machines. What selectEntity[V] actually does here is register a callback for the next time that the user clicks on an entity of type V, and when that callback is called, it continues with the rest of the interaction.\nWriting this sort of thing out explicitly would be a huge pain; monads allow us to pretend like these asynchronous calls are in fact synchronous, and the code is simply waiting until the user clicks.\nEssentially, actions form a DSL for scripting Semagrams; this DSL is what will make Semagrams very flexible and capable of rapidly being adapted to different use scenarios."
  }
]